package main

import (
	"flag"
	"fmt"
	"bytes"
	"go/format"
	"io/ioutil"
	"os"
	"strings"
	"golang.org/x/tools/go/packages"
)

var (
	Type = flag.String("T", "", "Type for which to generate data")
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

type Generator struct {
	buf bytes.Buffer // accumulate the output
	//pkg *Package // package being scanned
}

// currently hasgo works like this:
// once the generator is trigger, I scan all files in the named packages
// I generate one hasgo file with functions
// all the functions get  stored here
// I write out _once_, collecting all data
// Importantly, hasgo should trigger only once.. I should figure out how to do so
// todo: figure out how to run hasgo for user files. but should I even do so?

func main() {	
	flag.Parse()
	fmt.Printf("type: %v\n", *Type)
	g := Generator{}
	g.parsePackage(os.Args, nil)
	// stringer prints everything in one file. This might be bad. 
	// but let's roll with it for now :-)
	g.Printf("// Code generated by hasgo.go [DO NOT EDIT]")
	g.Printf("\n")
	// todo: unhardcode 
	g.Printf("package types\n")
	g.generate(*Type)
	ioutil.WriteFile(fmt.Sprintf("%v_hasgo.go",*Type), g.format(), 0644)
}

// write the data for the generator
func (g *Generator) generate(T string) {
	g.parsePackage([]string{"functions"}, []string{})
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}


// analyze the package
func (g *Generator) parsePackage(patterns []string, tags []string) {
	cfg := &packages.Config {
		Mode: packages.LoadSyntax,
		Tests: false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, patterns...)
	check(err)
	if len(pkgs) == 0{
		panic("not enough packages")
	}
	fmt.Printf("packages %v\n", pkgs)
}

// print the formatted source code
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// should never happen. During development, might.
		fmt.Println("Printing code without formatting")
		return g.buf.Bytes()
	}
	return src
}
